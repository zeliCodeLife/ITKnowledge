# 操作系统笔记

**纲要**：

1. 操作系统 - 进程及进程管理
   1. 基本概念
   2. 信号量
   3. 进程通信
2. 操作系统- 处理机调度
   1. 调度算法
3. 操作系统 - 资源分配与调度
   1. 死锁的避免：银行家算法
4. 操作系统 - 主存管理
   1. 分页式存储管理
   2. 分段式存储管理
   3. 段页式存储管理
   4. 请求分页式存储管理
5. 操作系统 - 设备管理
   1. 磁盘移臂调度算法
6. 操作系统 - 文件系统

-----------

## 1. 进程及进程管理

> [进程（上）](https://www.cnblogs.com/zrtqsk/p/4170666.html)
>
> [进程（下）](https://www.cnblogs.com/zrtqsk/p/4176879.html)
>
> [PV操作题集](https://wenku.baidu.com/view/06503bc902020740bf1e9b3f.html)

### 1. 什么是进程

定义：**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

进程的目的就是为了对并发执行的程序进行控制。进程实体由程序段、数据段、PCB三部分构成。

- 数据段就是各种数据
- 程序段就是一系列操作计算机的指令，即操作数据的方法策略
- PCB 即进程控制块（Process Control Block），控制运行程序段的时机。

进程的特征：

- 动态性
- 并发性
- 独立性
- 异步性
- 结构性

> 进程是什么？进程就是进程实体的运行过程，是一个过程。就是说，进程实体不运行，那就不叫进程。一个没有被调用的进程实体，不叫进程。**所以说，进程有动态的特征**。上面提到，进程的目的就是为了对并发执行的程序进行控制。为了在一个时间片内，运行多个程序才引进进程。**所以说，进程有并发的特征。**进程实体是一个拥有独立的资源（程序段和数据段）、（因为PCB）能独立地接受调度并独立的运行的基本单位。**所以说，进程有独立的特征**。进程运行的过程中，由于涉及到的资源众多、运行环境不一定，也受到其他进程的影响，所以，进程的运行情况是不可具体预知的。所以书本定义，进程按各自独立的、不可预知的速度向前推进。**所以说，进程有异步的特征。**如上文所说，进程是进程实体这一数据结构被调用运行。**所以说，进程有结构的特征。**

### 2. 进程的状态⭐

进程有3种基本状态：

1. **就绪状态**

   此时的进程拥有完整的进程实体，只要获得CPU，即只要被调用就能马上执行，这种状态被称为就绪状态。处于这种状态的进程都会被放进就绪队列，以便随时接受CPU调用。

1. **运行状态**

   此时的进程已经获得CPU，正在执行。

2. **阻塞状态**

   执行中的进程，因为某种原因（IO请求）无法继续执行的一种暂停状态，暂停完毕就会变成就绪状态。

除了3种基本状态外，有的系统还额外增加了一个状态：

4. **挂起状态**

   为什么需要挂起状态？因为有时候希望某些正在执行的线程暂停下来，持续一段时间后，让它回到之前的状态。

   挂起状态是一种静止的状态，相当于把某个进程从执行的流水线上拿出来，等到需要的时候再把它放进去继续执行。我们来看前三种基本状态，就绪 ->执行 -> 阻塞，阻塞完毕又回到就绪。由于线程的异步性，阻塞是会在不确定的有限时间内结束的。就是说，三种基本状态是动态的，通常不存在一个线程一直处于某种状态。挂起状态相对于它们来说，是静止的，因为它是被控制的，是对以不可预知的速度前进的线程的一种干扰。

此外，为了管理需要，通常还有两种比较常见的状态：

5. **创建状态**

   我们知道进程实体包括程序段、数据段和PCB。创建状态指的是PCB已经被创建，因为某些原因（程序段或数据段未放入内存等），进程还未被放入就绪队列的这种状态。

6. **终止状态**

   线程的终止也是有个过程的。终止状态指的是线程除了PCB以外的系统资源都被回收后的状态。此时线程真正终止。

状态的转换：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100312.png)



就绪态->执行态：处于就绪态的进程被调度后，，获得处理机资源（分派处理机时间片），于是进程由就绪态转换为执行态。

执行态->就绪态：处于执行态的进程在时间片用完后，不得不让出处理机，从而进程由执行态转换为就绪态。此外，当有更高优先级的进程就绪时，调度系统将正执行的进程转换为就绪态，让更高优先级的进程执行。

执行态->等待态：当进程请求某一资源的使用和分配或等待某一事件的发生时，它就从执行态转换为等待态。

等待态->就绪态：当进程等待的事件到来时，中断处理程序必须把相应进程的状态由等待态转换为就绪态。

### 3. 进程的核心：PCB

1. PCB是什么？

   作为进程实体的一部分，PCB是用来控制进程运行的一种数据结构。它包含了进程的状态、优先级、运行的状态、处理机状态、程序数据的内存地址等各种信息，一旦被操作系统调用，操作系统就从PCB中获取的信息，来恢复进程阻塞前的现场，继续执行。PCB一般都保存在CPU的寄存器中。

2. PCB包含的信息

   1. 进程标识符

      用来标识唯一的一个进程。包括方便系统调用的内部标识符和方便用户调用的外部标识符。进程标识符通常还包括父、子进程，以及所属用户等信息。

   2. 处理机状态信息

      处理机状态信息指的是处理机调用线程时的环境信息。处理机处理调用进程时，运行过程中的许多信息都放在处理机的寄存器中。进程阻塞或挂起时，寄存器中的运行信息会保存到PCB中，以便进程下次被调用时恢复之前的运行现场。

   3. 进程调度信息

      进程调度信息指的是本进程调度所需的必要信息。包括，本进程的状态（6种之一）、进程优先级、进程等待时间、进程执行时间（可能决定优先级）、阻塞原因、父子进程关系等。

   4. 进程控制信息

      进程控制信息指的是进程的资源信息和进程切换时的所需信息，包括进程的程序和数据的内存地址、进程同步和通信的机制、进程资源的清单、指向下一个进程PCB的指针（若PCB的组织方式是链接方式）等。

3. PCB的组织形式

   系统中拥有众多PCB，对应着众多进程，那么这些PCB怎么组织的呢？一般有两种组织方式：**链接方式**和**索引方式**。这两种方式的共同点在于，正在执行的PCB，都有一个执行指针指向它。不同在于，链接方式的就绪队列、阻塞队列等，通过指针链接的方式组织。进程切换时，直接取就绪队列指针即可，因为它指向的就是当前优先级最高的就绪的PCB，随后就绪队列指针指向其指向的下一个PCB。索引方式的就绪队列、阻塞队列等，通过一个表的形式来组织，就绪队列指针指向这个表的第一条数据。这个表本质是一个指针数组，第一个指针指向的当然是优先级最高的就绪进程。

### 4. 进程控制

进程控制的本质就是切换进程状态的控制，一般由操作系统中的原语实现。

> 原语：具有“原子操作”这种属性的若干指令集合，即这些指令要么全部执行，要么全部不执行。
>
> （不同操作系统的原语不同）

1. **进程创建**

   进程可能是由系统内核收到请求而创建，也可能由进程本身创建，由进程本身创建的进程一般是子进程，它继承父进程拥有的全部资源。创建进程由**进程创建原语**实现，通常由下面几个步骤：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100355.png)

2. **进程终止**

   进程的终止是由操作系统执行的。当一个进程因各种原因结束时，会通知操作系统。操作系统会调用**进程终止原语**来终止对应进程：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100409.png)

3. **进程阻塞**

   进程的阻塞是由进程自身主动执行的。但进程发现自身无法继续执行时，就主动调用**进程阻塞原语**，把自己阻塞：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100428.png)

4. **进程唤醒**

   进程的唤醒通常由其他线程执行。但其他线程由于某些事件希望执行线程执行时，会调用进程唤醒原语将指定进程唤醒：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100444.png)

5. **进程挂起或激活**

   进程挂起由自身或其他进程执行。进程激活由其他进程执行。

   1）进程挂起：若进程为活动就绪，就将其改为静止就绪；若进程为活动阻塞，就将其改为静止阻塞；若进程正在执行，则让调度程序重新调度。（由于没有挂起队列，所以需要把进程的PCB复制到指定的内存区域）

   2）进程激活：若进程为静止就绪，就将其改为活动就绪；若进程为静止阻塞，就将其改为活动阻塞；

### 5. 进程同步与互斥

> **同步**就是说一个任务要等另一个执行完毕才能继续执行，而不是同时执行。我们都知道，进程有异步性，这种性质会导致操作系统的混乱。进程同步，指的是进程之间的执行次序的管理，就是为了解决进程异步性的这种混乱。
>
> 与一个共享变量（或临界资源）交往的多个进程，为了保证它们各自运行结果的正确性，当其中的一个进程正在对该变量（或临界资源）进行操作时，就不允许其他进程同时对它进行操作。进程间的这种制约关系被称为**互斥**。

1. **直接制约和间接制约**

   进程之间有两种制约关系。分别是直接制约和间接制约。直接制约指的是进程间的合作，即一个进程需要另一个进程的配合，否则会阻塞。如输出缓冲区为空的时候，输出进程就会阻塞，输出进程依赖输入进程不断的输入。间接制约指的是对于某种资源，同时只能有一个进程占用，你用的时候，别人就不能用。

2. **同步机制应遵循的规则**

   这是所有的同步机制所需要遵循的规则 / 并发进程互斥访问临界区必须遵循的规则：

　　　　1）空闲让进。资源空闲的时候，允许进程访问。

　　　　2）忙则等待。资源被占用的时候，进程必须等待。

　　　　3）有限等待。应保证进程有限时间能访问到资源，不能无限等待。

　　　　4）让权等待。运行中的进程不能访问指定资源时，应释放处理机。

### 6. PV操作⭐

> 在荷兰文中，通过叫passeren，释放叫vrijgeven。

P操作又叫Wait(S)，本质是使用资源，V操作又叫Sign(S)，本质是释放资源。PV操作都是原子操作，要么全做，要么全不做，并且PV操作是成对的。PV操作与信号量分不开，先看看什么是信号量。

1. 什么是信号量？

   信号量是一种数据结构。包括整型信号量、记录型信号量、AND型信号量和信号量集等。

   不同的信号量对应不同的数据结构，也对应不同的PV操作。

   信号量和操作它的PV操作构成了对应的信号量机制，用来控制进程同步。

2. 整型信号量

   一般用整型变量S来表示，S代表的是资源数目。

   对于P操作，当资源数目小于等于0的时候，就一直等待。若有资源（S>0），就跳出循环，使用一个资源（S=S-1）。

   对于V操作，每次执行都释放一个资源（S=S+1）。

3. 记录型信号量

   这个信号量比整型信号量增加了一个标识进程指针的属性，指向所有等待的进程链表。

   PV操作与整形信号量的区别在于，Wait()时，若S<=0,那么阻塞自身，放弃处理机。Signal()后，判断若S<=0就唤醒一个进程。它的好处是当进程请求不到资源的时候，不会无限等待。

   ```c
   P(S){
   	S = S -1;
   	if (S <= 0) {
   		将进程置于等待（阻塞）状态
   		将该进程的PCB插入阻塞队列
   	}
   }
   V(S){
       S++;
       if(S <= 0) {
       	唤醒阻塞队列中的一个进程，改变为就绪态
       	将该进程的PCB插入就绪队列
       }
   }
   ```

   

4. AND型信号量

   AND型信号量是针对多个临界资源而言的。即将进程运行中所需要的所有资源一次性分配给进程，进程运行完毕后释放所有资源。相当于把进程所需的所有资源捆绑在一起了。做法就是在Wait操作中增加一个AND条件：只有当进程所需的所有资源处于空闲状态时，进程才能继续操作。

5. 信号量集

   信号量集指的是一次性对N个某类资源的请求处理。上面的AND型信号量指的是对多个不同类型资源的处理，而信号量集指的是对同类的多个资源的处理，也相当于AND型信号量的特殊情况。

6. 管程

   由于进程对某一个资源进行操作的时候，都需要自带一对PV操作，为了避免这种情况，把某个资源和进程对其进行的操作包装起来，这样的一个模块称为管程。它是操作系统中的一个资源管理模块，供进程调用。可以看到，管程实现了面向对象的思想。

7. 条件变量

   在上面的进程同步的实现中都有一个很严重的隐含问题，那就是，如果某个进程一直不释放某个资源，其他进程就只能无止休地等待。条件变量的意义在于，除了原本的资源空闲就让进、处理完就释放这样的逻辑外，还有其他的条件。例如：资源空闲且XX条件，就让进。处理完成或XX条件就释放资源。这些额外的条件，就叫条件变量。

**使用时的注意事项：**

1. PV操作都是成对出现的：
   1. 互斥操作时，它们在同一进程。
   2. 同步操作时，它们在不同进程。

### 7. 生产者与消费者模型⭐

1. **概念模型图**

   生产者与消费者模型描述的是有一块缓冲区作为仓库，生产者可将产品放入仓库（**生产**），消费者可以从仓库中取出产品（**消费**）。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100504.png)

2. **模型成立条件**

   1. 三种关系：消费者与消费者（竞争关系）、生产者与生产者（竞争关系）、生产者和消费者（依赖关系）
   2. 两类角色：生产者、消费者
   3. 一个交易场所：生产者与消费者进行数据交换的仓库，相当于一个缓冲区。

3. **模型特点**

   1. 生产者生产的时候消费者不能消费
   2. 消费者消费的时候生产者不能生产
   3. 缓冲区空时消费者不能消费
   4. 缓冲区满时生产者不能生产

4. **模型流程图**

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100517.png)

5. **要点**

   1. 每个进程中各个wait操作的次序是重要的：先检查资源数目，再检查是否互斥，否则可能死锁。
   2. 实现PV的互斥操作必须成对出现。

### 8. 读者写者模式⭐

> 读者和写者模型是操作系统中的一种同步与互斥机制，它与消费者和生产者模型类似，但也有不同的地方，最明显的一个特点是在读者写者模型中，多个多者之间可以共享“仓库”，读者与读者之间采用了并行机制；而在消费者和生产者模型中，消费者只能有一个独占仓库，消费者与消费者是竞争关系。

1. **概念模型图**

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100536.png)

2. **模型成立条件**

   1. 写者是排它性的，即在有多个写者的情况下，只能有一个写者占有仓库
   2. 读者的并行机制：可以运行多个读者去访问仓库
   3. 如果读者占有了仓库，那么写者不能占有。

3. **模型特点**
   1. 读者优先：读者先来读取数据，此时写者处于阻塞状态，当读者都读取完数据后且没有读者了时写者才可访问仓库
   2. 写者优先：类似读者优先的情况。
   3. 公平情况：写者和读者访问仓库的优先级相等，谁先进入优先级队列谁先访问。

4. **模型流程图**

   

5. **要点**

   

### 9. 进程通信

上面的通过信号量进行的进程同步，其本质是一种低级的通信机制。进程之间无法大量交换信息。那么两个进程之间想要实现大量的、频繁的信息交换，该怎么做呢？这就是高级通信机制了。高级通信机制有三大类：

1. **共享存储器系统**

   存储器即内存，共享存储器，顾名思义，就是通信的两个进程通过共享的一块内存区域来通信，一个负责读一个负责写。而实际上面的信号量也是一种共享存储器系统，只不过进程间共享的是一个数据结构，并用PV操作对数据结构进行操作。

2. **消息传递系统**

   进程间通过指定格式的消息进行通信。消息格式通常就是一个包含地址的头和一个包含内容的body。这种格式也叫做**协议**。我们常见的网络协议也是这种方式。消息传递系统分为直接通信方式和间接通信方式。直接通信方式即通信的进程双方都知道对方的存在，并在消息头中携带了自身和对方的地址信息。间接通信方式即进程间的消息传递不是直接传递给对方，而是有一个中间实体暂存、并转发，这样避免了进程双方接收、发送数据的速率不统一导致的进程阻塞。

3. **管道通信**

   管道是一种连接读进程和写进程的共享文件——pipe文件，其本质是固定大小的缓冲区，这个缓冲区将2个进程连接起来，这两个进程对管道是互斥的访问，且写进程写入数据后便阻塞，直到读进程取走所有数据才被唤醒继续写数据。这种一次性的读操作和写操作，虽然会导致进程堵塞，但是在读写的过程中无须维护读写指针，效率非常高。

#### 1. 管道

> 知识点：
>
> 无名管道与命名管道的创建、操作与区别。

> 管道（pipe）是允许两个或多个进程，使其之间彼此发送信息的IPC机制。
>
> 管道的读、写进程同时执行。
>
> 管道自动缓冲读、写进程的操作。

**分类：**

1. 无名管道（pipe）
2. 命名管道（named pipe， FIFO）

##### 1. **无名管道**

自动缓冲输入的单向通信链路，又叫匿名管道、未命名管道。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100556.png)

1. 创建无名管道

   ```c
   #include <unistd.h>
   int pipe(int filedes[2]); //Return value: 0 if success, -1 if failure
   ```

   > pipe函数创建一个未命名管道，并返回两个**文件描述符**，包括：
   >
   > 读端：filedes[0]
   >
   > 写端：filedes[1]

2. 无名管道的操作

   类似非缓冲文件的操作

   1. 读操作

      `ssize_t read(int fd, void *buf, size_t count);`

      若管道写端已关闭，则read返回0，表示输入结束。

      若管道写端打开，但无数据，read阻塞，等待输入。

      若请求的数据多于管道已有数据，read返回实际读取的数据量。

   2. 写操作

      `ssize_t write(int fd, const void *buf, size_t count);`

      若管道读端已关闭，则write失败，并产生SIGPIPE信号，终止进程。

      若管道缓冲不足，则write进程将保证能够完成其系统调用，不会被其他进程抢占。

   3. 关闭读端

      `close(filedes[0])`

   4. 关闭写端

      `close(filedes[1])`

3. 无名管道的使用范围

   由于无名管道通过描述符来操作，一般只有创建管道的进程和其子进程才能访问。

   因此，**无名管道主要用于父子进程间的通信**。

##### 2. 命名管道

1. 与无名管道相比：
   1. 存在一个文件系统的名字
   2. 可以被不相关的进程使用
   3. 更加灵活

2. 命名管道的创建

   1. 命令行方式

      `mkfifo fifoname`创建FIFO

      `cat < /tmp/myfifo` 读FIFO文件

      `echo "hello" > /tmp/myfifo` 向FIFO文件写

   2. 代码方式

      ```
      #include <sys/types.h>
      #include <sys/stat.h>
      int mkfifo(const char *pathname, mode_t mode);		(Returned value: 0 if success, -1 if failure)
      ```

      创建一个FIFO文件，注意是创建一个真实存在于文件系统中的文件，filename指定了文件名，mode则指定了文件的读写权限。

      mode_t： O_RDONLY只读、O_WRONLY只写、O_RDWR可读写（三个主标志，除此之外还有副标志）

3. 命名管道的操作

   打开FIFO文件有四种方式

   ```c
   open(const char *filename,O_RDONLY);
   open(const char *filename,O_RDONLY|O_NONBLOCK);
   open(const char *filename,O_WRONLY);
   open(const char *filename,O_WRONLY|O_NONBLOCK);
   ```

   注意：不能以O_RDWR可读写模式打开，因为这样一个进程刚写的数据就被自己读出来了。

   O_NONBLOCK表示FIFO管道的读写是非阻塞的，默认为阻塞。

   > 何为阻塞？
   >
   > 一个进程写模式打开管道的时候，必须有另一个进程以读模式打开；
   >
   > 或读模式的时候，必须有另一个进程写写模式打开，否则该进程open函数阻塞，直到满足以上关系。
   >
   > 非阻塞，意味着open函数会立即返回，若没有其他进程以只读方式打开，open返回-1，并且FIFO也不会被打开。

4. 注意

   1. 两个进程打开一个命名管道时，必须以“只”的方式打开，且必须相反。
   2. 命名管道两端需要同时打开。
   3. 创建命名管道时，若该路径已存在同名文件，则创建会失败。为避免此现象，一般使用完会删除。

5. 多进程同时写管道的解决思路💡

   > 当多个进程同时写管道时，读管道取得的数据是杂乱的。
   >
   > 此时，我们可以控制每个进程，当要写入的数据超过某个大小时，才写管道，另外要以阻塞的方式打开FIFO。确保写操作的原子性。

6. 命名管道的应用

   1. C/S结构：客户机用FIFO向服务器发送请求，客户机-服务器用FIFO进行通信。

   2. 用命名管道实现聊天功能。

#### 2. Socket通信

Socket，中文译名 套接字。

> 知识点：
>
> 网络基础、TCP、UDP、TCP/IP协议栈、本机字节序与网络字节序。

1. TCP/IP参考模型（五层协议体系结构）

   ```
   5. 应用层（Application）
   4. 传输层（Transport）
   3. 网络层（Network）
   2. 数据链路层（Data Link）
   1. 物理层（Physical）
   ```

   相较于OSI/RM的7层协议，更加简化，实用。

   缺点是通用性较差，难以描述其他种类的协议栈。

2. TCP/IP协议族

   TCP协议和IP协议是网络体系结构的关键之一。事实上，TCP/IP是一个协议族，它是ARP，IP，ICMP，IGMP，UDP，TCP等多个协议的集合。

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100612.png)

3. TCP - 传输控制协议

   特点：

   1. 面向连接
   2. 可靠，有序的字节流传输
   3. 流量控制与拥塞控制

4. UDP - 用户数据报协议

   特点：

   1. 无连接
   2. 不可靠的，但是传输速度快的数据传输
   3. 无流量控制、无拥塞控制


## 2. 处理机调度

> [处理机调度](https://www.cnblogs.com/zrtqsk/p/4192091.html)

### 1. 处理机调度

处理机调度程序按照某种算法将处理机分配给某个进程，这就叫处理机调度。

1. 作业调度（又称高级调度、长程调度）

   作业调度的本质就是根据某种算法，把外存上的作业（后备作业队列中的作业）调入内存，并为之创建进程，分配处理机并执行。

   **作业的生命期：**从作业提交到作业完成或撤销。

   **作业的基本状态：**提交状态、后备状态、运行状态、完成状态。

1. 进程调度（又称低级调度、短程调度）

   进程调度的本质就是根据某种算法，把处理机分配给进程。

2. 中级调度

   中级调度的本质就是让暂时不能运行的进程挂起，释放内存资源，并把它们调到外存上去等待。

### 2. 调度算法⭐

需要了解的名词：

1. 服务时间：进程总共需要占用处理机的时间长度
2. 开始执行时间：进程开始执行的时间点
3. 完成时间：进程执行完毕的时间点
4. 周转时间（描述系统的吞吐量）：完成时间-到达时间
5. 带权周转时间：周转时间/服务时间
6. 到达时间：进程进入就绪队列的时间点
7. 平均周转时间 = 所有作业的周转时间/作业总数 

调度算法包括：

#### 1. 先来先服务调度算法⭐

按作业的到达时间进行调度，先到达先服务。

#### 2. 最短作业优先调度算法⭐

优先执行所需时间最短的作业。

#### 3. 最高响应比优先调度算法⭐

优先执行响应比高的作业。

`响应比 = （等待时间 + 服务时间） / 服务时间`

#### 4. 高优先权优先调度算法

优先执行优先级高的作业。

#### 5. 基于时间片的轮转调度算法

按照先进先出的规则给作业分配时间片，时间片结束后不管作业有没有执行完毕，都将执行下一个进程。

#### 6. 多级反馈队列调度算法

5个就绪队列，优先级递减，时间片递增。

如果某个进程进入就绪队列，先进入第一个就绪队列的末尾，轮到它执行的时候执行，如果没有执行完，则放入第二个就绪队列的末尾。

只有第一个就绪队列的进程都执行完毕后才会执行第二个就绪队列的进程。所以处理机执行过程中，只有当优先级高的队列中的线程都执行完毕，才会执行优先级低的队列。

## 3. 资源分配与调度

### 死锁

> 多个进程在运行过程中因争夺资源造成的一种僵局。

#### 1. 产生的必要条件

1. 互斥条件
2. 不剥夺条件（非抢占）
3. 占有并等待（部分分配）
4. 环路条件（循环等待）

#### 2. 死锁的避免⭐

1. 有序资源分配法



2. 银行家算法⭐

https://blog.csdn.net/qq_33414271/article/details/80245715

> Allocation：已分配资源数
>
> Max：对资源的最大需求数
>
> Need：尚需资源数 = Max - Allocation
>
> Available：可利用资源数

- **安全性算法**

  假设资源P1申请资源，银行家算法先试探的分配给它（当然先要看看当前资源池中的资源数量够不够），若申请的资源数量小于等于Available，然后接着判断分配给P1后剩余的资源，能不能使进程队列的某个进程执行完毕，若没有进程可执行完毕，则系统处于不安全状态（即此时没有一个进程能够完成并释放资源，随时间推移，系统终将处于死锁状态）。

  若有进程可执行完毕，则假设回收已分配给它的资源（剩余资源数量增加），把这个进程标记为可完成，并继续判断队列中的其它进程，若所有进程都可执行完毕，则系统处于安全状态，并根据可完成进程的分配顺序生成安全序列（如{P0，P3，P2，P1}表示将申请后的剩余资源Work先分配给P0–>回收（Work+已分配给P0的A0=Work）–>分配给P3–>回收（Work+A3=Work）–>分配给P2–>······满足所有进程）。

- **进程请求向量Request(x,x,x)时，如何检查是否安全**

  设Requesti是进程Pi的请求向量
  Requesti［j］=K，表示进程Pi需要K个Rj类型的资源。
  当进程Pi发出资源请求后，系统按下述步骤进行检查：
   (1) 如果Requesti［j］≤Need［i,j］，便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
  (2) 如果Requesti［j］≤Available［j］，便转向步骤(3)；否则表示尚无足够资源，Pi等待。

  (3)系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：
   Available[j]:=Available[j]-Requesti [j];
    Allocation[i,j]:=Allocation[i,j] + Requesti[j] 
   Need[i,j ]:= Need[i,j] - Requesti[j];
   (4) 系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，完成本次分配；否则， 将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。

例题：

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100629.png)

（1）该状态是否安全？ （2）若进程P2提出请求Request（1，2，2，2）后，系统能否将资源分配给它？

（1）利用安全性算法对上面的状态进行分析（见下表），找到了一个安全序列{P0,P3,P4,P1,P2}，故系统是安全的。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100653.png)

（2）P2发出请求向量Request(1,2,2,2),系统按银行家算法进行检查：

①Request2(1,2,2,2)<=Need(2,3,5,6)
②Request2(1,2,2,2)<=Available(1,6,2,2)
③系统先假定可为P2分配资源，并修改Available，Allocation2和Need2向量：
Available=(0,4,0,0)
Allocation2=(2,5,7,6)
Need2=(1,1,3,4)

此时再进行安全性检查，发现	Available=(0,4,0,0) 不能满足任何一个进程，所以判定系统进入不安全状态，即不能分配给P2相应的Request(1,2,2,2)。



例题2：

| **进程名** | **剩余资源** | **已分配资源** | **尚需资源** | **剩余资源+已分配资源** | **能否完成** |
| ---------- | ------------ | -------------- | ------------ | ----------------------- | ------------ |
| P1         | 3 3 2        | 2 0 0          | 1 2 2        | 5 3 2                   | true         |
| P3         | 5 3 2        | 2 1 1          | 0 1 1        | 7 4 3                   | true         |
| P2         | 7 4 3        | 3 0 2          | 6 0 0        | 10 4 5                  | true         |
| P0         | 10 4 5       | 0 1 0          | 7 4 3        | 10 5 5                  | true         |
| P4         | 10 5 5       | 0 0 2          | 4 3 1        | 10 5 7                  | true         |

安全序列{P1，P3，P2，P0，P4}

如果此时P0进程申请资源{3，2，1}，能否给于分配？为什么？ 

①Request2(3,2,1)<=Need2(7,4,3)
②Request2(3,2,1)<=Available(3,3,2)

③系统先假定可为P0分配资源，并修改Available，Allocation2和Need2向量：
Available=(3,3,2)-(3,2,1)=(0,1,1)
Allocation2=(0,1,0)+(3,2,1)=(3,3,1)
Need2=(7,4,3)-(3,2,1)=(4,2,2)

此时再进行安全性检查

| **进程名** | **剩余资源** | **尚需资源** | **已分配资源** | **剩余资源+已分配资源** | **能否完成** |
| ---------- | ------------ | ------------ | -------------- | ----------------------- | ------------ |
| P3         | 0 1 1        | 0 1 1        | 2 1 1          | 2 2 2                   | true         |
| P1         | 2 2 2        | 1 2 2        | 2 0 0          | 4 2 2                   | true         |
| P0         | 4 2 2        | 4 2 2        | 3 3 1          | 7 5 3                   | true         |
| P2         | 7 5 3        | 6 0 0        | 3 0 2          | 10 5 5                  | true         |
| P4         | 10 5 5       | 4 3 1        | 0 0 2          | 10 5 7                  | true         |

安全，可以分配。

## 4. 主存管理

> [存储器管理](https://www.cnblogs.com/zrtqsk/p/4195976.html)

### 4.1 地址重定位

程序在成为进程前的准备工作

1. 编辑：形成源文件
2. 编译：形成目标模块
3. 链接：由多个目标模块或程序库生成可执行文件
4. 装入：构成PCB，形成进程（使用物理地址）

逻辑地址（相对地址，虚地址）：用户的程序经过汇编或编译后形成目标代码，目标地址采用相对地址。

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100709.png)

地址映射：将用户程序中的逻辑地址转换为运行时由机器直接寻址的物理地址。



静态重定位：在程序运行前，完成地址重定位

动态重定位：利用定位寄存器，存储该程序的物理空间起始地址，然后加上指令中的相对地址，完成地址定位。

### 4.2 内存管理

#### 4.2.1 单一连续分区存储管理

内存分为：系统区，用户区，应用程序装入用户区。

适用于单用户、单任务的OS，易于管理，但是易造成内存浪费。

#### 4.2.2 固定分区存储管理

把内存分为大小相等或不等的分区，每个进程占用1个或几个分区。例如8KB、32KB、64KB、132KB。

易于实现，开销小， 可多道并行，静态重定位。但是可能存在内碎片和外碎片。分区总数固定，限制了并发执行的程序数量。

#### 4.2.3 可变分区存储管理

动态创建分区：在装入程序时按其初始要求分配，或执行过程中通过系统调用进行分配或改变分区大小。

特点：

1. 作业一次性全部装入连续的存储分区

2. 分区按需要划分
3. 需要动态重定位

缺点：

1. 没有解决小内存运行大作业的问题
2. 引起外部碎片
3. 需要进行分区合并

### 4.3 空闲分区的分配算法

#### 4.3.1 最先适应算法（first-fit）

按分区的先后次序，从头查找，找到符合要求的第一个分区。

#### 4.3.2 最佳适应算法（best-fit）

找到其大小与要求相差最小的空闲分区

#### 4.3.3 最坏适应算法（worst-fit）

找到最大的空闲分区

### 4.4 分页式存储管理⭐

将程序的逻辑地址空间和物理内存划分为固定大小的页或页面，程序加载时， 分配其所需的所有页，这些页不需要连续，需要CPU硬件支持。

地址转换公式⭐：

页号 = 相对地址 / 块尺寸

页内地址 = 相对地址 % 块大小



进程页面：每个进程有一个页表，描述该进程占用的物理页面及逻辑排列顺序。

逻辑页号 -> 物理页面号/块号

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100725.png)

特点：页表在内存，一条指令执行至少需要访问两次内存。

相联存储器：一组快速硬件寄存器，能够按内容访问。

块表：相联存储器中存放的页表的一部分

命中率：通过快表实现内存访问的成功率

> 假定CPU访问一次内存时间为200ns，访问一次快表时间为40ns，快表命中率为90%，试问现在进行一次内存存取的平均时间是多少？比只采用页表下降了多少？
>    采用快表：
>  （200＋40）×90%＋(40+200+200)×(1-90%)＝260ns
>   只采用页表：
>    两次访问主存的时间:
>    200ns×2＝400ns。

#### 4.4.1 内存块的分配和回收

1. 存储分块表：操作系统设一张表格，记录内存中每一块使用情况。
2. 位图： 用二进制位与内存块的使用状态建立起联系，0为空闲，1为已分配
3. 单链表

#### 4.4.2 分页式特点

1. 内存被分成大小相等的块
2. 用户作业相对地址空间被分成相同大小的页
3. 不要求占用连续存储空间
4. 有内部碎片，平均不超过半页
5. 要求全部装入内存

### 4.5 分段式存储管理

将程序的地址空间划分为若干个段(segment)，程序加载时，分配其所需的所有段（内存分区），这些段不必连续；物理内存的管理采用动态分区。需要CPU的硬件支持。

特点：

1. 方便编程
2. 信息共享
3. 信息保护
4. 动态增长
5. 动态链接

分页与分段区别：

1. 页是信息的物理单位，段是信息的逻辑单位
2. 页的尺寸由系统确定，段的尺寸因段而异
3. **分页的目的是为提高内存的利用率。**
4. 页式地址空间是一维的，段式地址空间式二维的
5. **分段的目的是为了能更好地满足用户的需要**



**地址转换步骤：**
（1）从CPU给出的相对地址数对：[段号s，段内位移d]中提取段号
（2）如果段号大于段表长度，越界出错；否则查找段表， 得到段在内存起始地址
（3）用相对地址中的段内位移d与该段段长比较，大于段长， 则地址出错；否则绝对地址＝段的基址＋段内位移

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100742.png)

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100753.png)

### 4.6 段页式存储管理

分段和分页原理的结合
即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。



### 4.7 虚拟存储与请求页式存储管理

#### 4.7.1 虚拟存储

前提：局部性原理（分段和分页原理的结合
即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。）

通过系统提供的缺页/段中断功能和交换技术，动态装入进程的程序代码和数据，为用户提供一个比物理主存容量大得多的，可寻址的一种“主存储器”。 
    用户感觉上的，由实际内存和部分外存构成的存储空间称为“虚拟存储器”。



#### 4.7.2 请求页式存储管理

在简单页式存储管理的基础上，增加请求调页和页面置换功能。

允许只装入少数页面的程序(及数据)，便启动运行。以后，再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。



#### 4.7.3 缺页中断

缺页率=缺页次数/内存访问次数

影响因素：

1. 分配给作业的内存块数
2. 页面尺寸
3. 程序的实现

**页面淘汰算法：**⭐

需要调入页面时，选择内存中哪个物理页面被置换。称为replacement policy。

1. 最佳算法(OPT, optimal)

   选择“未来不再使用的”或“在离当前最远位置上出现的”页面被置换。

   理想情况，是实际执行中无法预知的，不能实现。
   可用作性能评价的依据。

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100817.png)

   

2. 先进先出算法(FIFO)

   选择建立最早的页面被置换。可以通过链表来表示各页的建立时间先后。

   性能较差。较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出。并且有Belady现象。

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100829.png)

   

3. 最近最久未使用算法(LRU, Least Recently Used)

   选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100838.png)

   

4. 最少使用算法(LFU, Least Frequently Used)

   选择到当前时间为止被访问次数最少的页面被置换；
   每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；
   发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零；

   

![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100848.png)

## 5. 设备管理

### 5.1 基本概念

#### 5.1.1 设备分类

1. 按设备从属关系

   系统设备

   用户设备

2. 按设备分配特性

   独享设备

   共享设备

   虚拟设备

3. 按设备工作特性

   输入/输出设备

   存储设备

#### 5.1.2 设备管理的目标和功能

目标：

1. 提高外设利用率
2. 为用户提供便利、统一的使用界面

功能：

1. 提供一组I/O命令
2. 进行设备的分配与回收
3. 对缓冲区管理
4. 实现真正的I/O操作

### 5.2  磁盘移臂调度算法

磁盘访问过程：

1. 查找：磁头移动定位到指定磁道
2. 等待：等待指定扇区旋转到磁头下
3. 传输：数据在磁盘与内存之间的实际传输

扇区编号⭐：

> 为了对扇区进行查找和管理，需要对扇区进行编号，扇区的编号从0磁道开始，起始扇区为1扇区，其后为2扇区、3扇区……，0磁道的扇区编号结束后，1磁道的起始扇区累计编号，直到最后一个磁道的最后一个扇区（n扇区）。例如，某个硬盘有1024个磁道，每个磁道划分为63个扇区，则0磁道的扇区号为1~63，1磁道的起始扇区号为64最后一个磁道的最后一个扇区号为64512。硬盘在进行扇区编号时与软盘有一些区别，在软盘的一个磁道中，扇区号一次编排，即1、2、3……n扇区。由于硬盘的转速较高，磁头在完成某个扇区数据的读写后，必须将数据传输到微机，这需要一个时间，但是这时硬盘在继续高速旋转，当数据传输完成后，磁头读写第二个扇区时，磁盘已经旋转到了另外一个扇区。因此在早期硬盘中，扇区号是按照某个间隔系数跳跃编排的。

#### 5.2.1 先来先服务（FCFS）

根据进程请求访问磁盘的先后次序进行调度。

#### 5.2.2 最短寻道时间优先（SSTF）

优先选择访问的磁道与当前磁头所在磁道距离最近的进程，使每次寻道时间最短，但不能保证平均寻道时间最短。

#### 5.2.3 扫描算法（SCAN）（电梯调度算法）

不仅要考虑要访问的磁道与当前磁道的距离，更优先考虑磁头当前移动的方向。

#### 5.2.4 单向扫描调度算法（CSCAN）

SCAN存在的问题：当磁头刚从头到外移动过某一磁道，恰有一进程请求访问此磁道，这时该进程必须等待磁头从里向外再从外向里扫描完才处理该进程。

## 6. 文件系统

### 6.1 基础概念

#### 6.1.1 文件的分类

1. 按文件的性质和用途

   1. 系统文件
   2. 用户文件
   3. 库文件

2. 按文件的保护性质

   1. 只读文件
   2. 读写文件
   3. 可执行文件
   4. 不保护文件

3. 按文件的保护期限

   1. 临时文件
   2. 档案文件
   3. 永久文件

4. 按文件的存取方式

   1. 顺序存取文件：磁带机
   2. 随机存取文件：磁盘

5. 按设备的类型

   1. 磁盘文件
   2. 磁带文件
   3. 打印文件

6. 按文件的逻辑结构

   1. 流式文件：把文件视为有序的字符集合，其内部不再对信息进行组织划分。

      例如：源程序、可执行程序、库函数

   2. 记录式文件：把文件信息划分为一个个记录，存取以记录为单位进行

      例如：数据结构和数据库

   ![](https://keyon-photo-1256901694.cos.ap-beijing.myqcloud.com/markdown/20200102100905.png)

7. 按文件的物理结构

   1. 连续文件
   2. 链接文件
   3. 索引文件

8. 按文件的内容

   1. 普通文件
   2. 目录文件
   3. 特殊文件



#### 6.1.2 磁盘存储空间

1. 概念
   1. 柱面
   2. 磁道（盘面）
   3. 扇区（块）

2. 计算公式

   字长为m，那么第i字第j位对应的相对块号k是：k=i*m + j

   柱面号=k / m

   磁盘号=（k % m）/n

   扇区号=（k % m）% n

   相对块号k = 柱面号*m + 磁头号*n + 扇区号

   字号  = k / m

   位号 = k % m

3. 位示图

   位示图中的每个二进制位与一个磁盘块（假定一个扇区就是一个磁盘块）对应，该位为“1”，表示对应的块已分配；为“0”，表示对应的块空闲，可以参加分配。 

4. 空闲区表

   记录磁盘空间中的一个连续空闲盘区的信息，比如该空闲盘区的起始空闲块号、连续的空闲块个数、以及表目的状态

5. 空闲块链

   在磁盘的每个空闲块里设一个指针，指向另一个磁盘空闲块，所有的空闲块形成一个链表，即空闲块链。



## 其他

最短作业优先调度算法

周转时间（描述系统的吞吐量）：完成/结束时间-到达/提交时间

平均周转时间 = 所有作业的周转时间/作业总数 = （40+15+35+90） /  4 = 45

| 作业名 | 提交时间 | 执行时间 | 开始执行时间 | 结束时间 | 周转时间 |
| ------ | -------- | -------- | ------------ | -------- | -------- |
| J1     | 0        | 40       | 0            | 40       | 40       |
| J3     | 30       | 5        | 40           | 45       | 15       |
| J4     | 35       | 25       | 45           | 70       | 35       |
| J2     | 20       | 40       | 70           | 110      | 90       |



最高响应比优先调度算法

响应比 = （服务时间 + 等待时间） / 服务时间

平均周转时间 = 所有作业的周转时间/作业总数 = 

服务/执行时间：进程总共需要占用处理机的时间长度

等待时间 = 开始执行时间 - 提交时间

| 作业名 | 提交时间 | 执行时间 | 开始执行时间 | 结束时间 | 周转时间 |
| ------ | -------- | -------- | ------------ | -------- | -------- |
| J1     | 0        | 40       | 0            | 40       | 40       |
| J3     | 30       | 5        | 40           | 45       | 15       |
| J2     | 20       | 40       | 45           | 85       | 65       |
| J4     | 35       | 25       | 85           | 110      | 75       |

J1 - ：

​	J2 响应比 = （40+20）/40 = 1.5

​	J3 响应比 = （5+10）/5 = 3

​	J4 响应比 = （25+5）/25 = 1.2

所以J3先执行，40开始，45结束

J3 - ：

​	J2响应比：（40+45-20）/40 = 65/40 = 1.625

​	J4响应比：（25+45-35）/25 = 35/25 = 1.4

所以J2先执行，最后J4执行。

平均周转时间 = 48.75

